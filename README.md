# 데이터 베이스
 - 데이터베이스: 파일이 가진 한계(보안,편의성)를 극복하기 위해 나온 전문화된 소프트웨어.
 - 발전순서:파일-> 스프레드시트-> 데이터베이스

-차이점
 - 스프레드시트
   - 클릭과 같은 작용으로 데이터를 조작한다.
 - 데이터베이스
   
   1.sql이라는 컴퓨터언어를 이용하여 데이터를 제어할 수 있다. 즉 코드를 통해서 데이터를 조작할 수 있다.
   
   2.컬럼(행)을 작성할 때 구조(형태)를 강제할 수 있다. 

-목적:데이터를 표의 형태로 정리정돈 할 수 있고 정렬.검색과 같은 작업을 빠르고 편리하고 안전하게 할 수 있다.

------------------------------------------------------------------------------------------------------------
# 데이터베이스의 본질

데이터베이스란 입력과 출력으로 이루어져있다.


 - 입력

   1.Create
   
   2.Update
   
   3.Delete

    
 - 출력
   
   4.Read
- 이것들을 CRUD라고 부른다.
------------------------------------------------------------------------------------------------------------
- 서로 연관된 데이터들을 그룹핑해서 연관되어있는 않은 데이터들과 분리하는 일종의 폴더 : 데이터베이스 = 스키마(schema)
- 스키마의 묶음 : 데이터베이스 서버
- 포함관계: 표(table) (-- 데이터베이스(스키마) (-- 데이터베이스 서버 
------------------------------------------------------------------------------------------------------------
# 데이터베이스의 효용
- 보안성 : 별도의 사용자 별로 차등적으로 권한을 줄 수 있음
------------------------------------------------------------------------------------------------------------
# SQL
- SQL이란 Structured Qurery Languaged의 약자로 구조화된 쿼리 언어로 관계형 데이터베이스에서 데이터를 조작하고 쿼리하는 표준 수단임.
- 데이터를 보다 쉽게 검색하고 추가, 삭제, 수정 같은 조작을 할 수 있도록 고안된 컴퓨터 언어임.

- 종류
   - DML (Data Manipulation Language): 데이터를 조작하기 위해 사용합니다.
     
     INSERT, UPDATE, DELETE, SELECT 등이 여기에 해당합니다.
   - DDL (Data Definition Language): 데이터베이스의 스키마를 정의하거나 조작하기 위해 사용합니다.
     
     CREATE, DROP, ALTER 등이 여기에 해당합니다.
   - DCL (Data Control Language) : 데이터를 제어하는 언어입니다.
     
     권한을 관리하고, 테이터의 보안, 무결성 등을 정의합니다.
     
     GRANT, REVOKE 등이 여기에 해당합니다.
------------------------------------------------------------------------------------------------------------
# Table
- 데이터를 저장하는 공간 테이블(Table)

  마이크로소프트의 엑셀(Excel)을 실행하면 표가 나옵니다. 이러한 표에 각종 값을 저장할 수 있습니다.
  
  데이터베이스도 엑셀의 표와 유사한 테이블을 가질 수 있습니다.
  
  엑셀과 다른 점은 데이터베이스를 생성해도 테이블은 존재하지 않는다는 것입니다.
  
  테이블을 사용하려면 테이블을 생성하는 SQL을 사용해야 합니다.
  
  그리고, 테이블에 값을 저장하려면 저장하기 위한 SQL을 사용해야 합니다.

![2_8_1_(table)_](https://github.com/parkminseok56/Oracle/assets/133790403/2a33e657-4862-4b6b-aebd-9da3bd477b40)


- 테이블(table)의 구성요소
  - 테이블 : RDBMS의 기본적 저장구조 한 개 이상의 column과 0개 이상의 row로 구성합니다.
  - 열(Column) : 테이블 상에서의 단일 종류의 데이터를 나타냄. 특정 데이터 타입 및 크기를 가지고 있습니다.
  - 행(Row) : Column들의 값의 조합. 레코드라고 불림. 기본키(PK)에 의해 구분. 기본키는 중복을 허용하지 않으며 없어서는 안 됩니다.
  - Field : Row와 Column의 교차점으로 Field는 데이터를 포함할 수 있고 없을 때는 NULL 값을 가지고 있습니다.
  - 
------------------------------------------------------------------------------------------------------------
# 데이터 조작어(Data Manipulation Language, DML)의 종류

데이터 조작어는 모두 동사로 시작합니다.

시작하는 동사에 따라서 다음과 같은 4가지 조작어가 있습니다.

 - SELECT : 검색
 - INSERT : 등록
 - UPDATE : 수정
 - DELETE : 삭제
   
------------------------------------------------------------------------------------------------------------
 - SELECT 구문의 기본문형
   
![2_8_2_select__](https://github.com/parkminseok56/Oracle/assets/133790403/9dc39ac6-a75a-48c1-8e7b-8f70dca40086)

 - ORDER BY 구문

![2](https://github.com/parkminseok56/Oracle/assets/133790403/90e06177-9dd7-4026-acf5-07cb70d01b91)

 - WHERE 조건 구문

![3](https://github.com/parkminseok56/Oracle/assets/133790403/9458411d-2a71-4db2-858b-a0fad1d7f842)

------------------------------------------------------------------------------------------------------------

- GROUP BY 구문
  
  - 데이터를 그룹화하여 집계 함수(예: SUM, COUNT, AVG 등)와 함께 사용하여 그룹별로 집계를 수행하는 데 사용되는 절입니다.

    GROUP BY를 사용하면 특정 열의 값에 따라 데이터를 그룹으로 분류하고, 각 그룹에 대한 집계 연산을 수행할 수 있습니다.

- GROUP BY 구문의 기본 

```
SELECT column1, column2, ...
FROM table_name
GROUP BY column_name1, column_name2, ...;
```

여기서 각 부분의 역할은 다음과 같습니다:

- SELECT: 검색할 열(column)을 지정합니다.

- FROM: 데이터를 가져올 테이블을 지정합니다.

- GROUP BY: 그룹화를 수행하는 키워드입니다.

- column_name1, column_name2, ...: 그룹화할 열(column)의 이름을 지정합니다. 하나 이상의 열을 지정할 수 있으며, 각 열 이름은 쉼표로 구분합니다.

-----------------------------------------------------------------------------------------------------------

- GROUP BY를 사용할 떄

  - 데이터를 특정 열의 값에 따라 그룹화할떄.
   
  - 각 그룹에 대해 집계 함수를 사용하여 데이터를 요약할 때.
   
  - 각 그룹의 합계, 평균, 최대값 또는 최소값을 계산할 때.

------------------------------------------------------------------------------------------------------------

- HAVING 구문

   SQL 질의의 결과를 그룹화한 후, 그룹화된 결과에 대한 조건을 필터링하는 데 사용됩니다.

   HAVING은 GROUP BY와 함께 사용되며, 주로 집계 함수와 함께 사용하여 그룹화된 데이터에서 특정 조건을 충족하는 그룹만 선택할 때 유용합니다.

 - HAVING 구문의 기본 구조

```
SELECT column1, column2, ...
FROM table_name
GROUP BY column1, column2, ...
HAVING condition;
```
여기서 각 부분의 역할은 다음과 같습니다:

- SELECT: 검색할 열(column)을 지정합니다.

- FROM: 데이터를 가져올 테이블을 지정합니다.

- GROUP BY: 그룹화할 열을 지정합니다. 이 열을 기준으로 데이터가 그룹화됩니다.

- HAVING: 그룹화된 데이터에 적용할 조건을 지정합니다. HAVING 뒤에 나오는 조건이 참인 그룹만 결과에 포함됩니다.

------------------------------------------------------------------------------------------------------------
 - INSERT 구문의 기본문형
   
INSERT INTO 테이블명(필드1, 필드2, 필드3, 필드4, ...)
VALUES (필드1의 값, 필드2의 값, 필드3의 값, 필드4의 값, ...);


INSERT INTO 테이블명
VALUES (필드1의 값, 필드2의 값, 필드3의 값, 필드4의 값, ...);

필드명을 지정해주는 방식은 디폴트 값이 세팅되는 필드는 생력할 수 있습니다.
필드명을 지정해주는 방식은  추 후, 필드가 추가/변경/수정 되는 변경에 유연하게 대처 가능합니다.
필드명을 생략했을 경우에는 모든 필드 값을 반드시 입력해야 합니다.
 
------------------------------------------------------------------------------------------------------------

 - UPDATE 구문의 기본문형

 UPDATE  테이블명
        SET  필드1=필드1의값, 필드2=필드2의값, 필드3=필드3의값, …
   WHERE  조건식
   
조건식을 통해 특정 row만 변경할 수 있습니다.
조건식을 주지 않으면 전체 로우가 영향을 미치니 조심해서 사용하도록 합니다.

------------------------------------------------------------------------------------------------------------

 - DELETE 구문의 기본문형
  
   DELETE
      FROM  테이블명
WHERE  조건식
    
조건식을 통해 특정 row만 삭제할 수 있습니다.
조건식을 주지 않으면 전체 로우가 영향을 미치니 조심해서 사용하도록 합니다.

------------------------------------------------------------------------------------------------------------

# JOIN 

JOIN은 데이터베이스 내의 여러 테이블에서 가져온 레코드를 조합하여 하나의 테이블이나 결과 집합으로 표현해 줍니다.

이러한 JOIN은 보통 SELECT 문과 함께 자주 사용됩니다.

 

표준 SQL에서는 레코드를 조합하는 방식에 따라 JOIN을 다음과 같이 구분합니다.

 

1. INNER JOIN
   
2. LEFT JOIN

3. RIGHT JOIN

   INNER JOIN 에서 INNER는 생략이 가능하며, LEFT JOIN 과 RIGHT JOIN을 합쳐서 OUTTER JOIN이라고 부릅니다.

   두 테이블의 모든 내용을 합치는 FULL JOIN도 존재합니다. (MY SQL에서는 지원하지 않습니다.)

 - 기타
   - 크로스 조인(Cross Join)
     - 크로스 조인은 두 테이블 사이의 모든 가능한 조합을 생성합니다.
    
     -  이는 매우 비효율적이며 데이터베이스에서는 주의해서 사용해야 합니다.
      
     -  보통 크로스 조인은 조건 없이 두 테이블을 단순히 결합하려는 경우에 사용됩니다.
       
     -  크로스 조인은 결과가 매우 크고 복잡할 수 있으므로 신중하게 사용해야 합니다.
 
 예시
```
 SELECT *
 FROM table1
 CROSS JOIN table2;
```
 
  - 네츄럴 조인(Natural Join)
 
    - 네츄럴 조인은 두 테이블 사이에서 동일한 이름을 가진 열을 기반으로 자동으로 조인을 수행합니다.
     
    -  이 조인 유형은 열 이름이 일치하는 경우에만 사용할 수 있으며, 일치하지 않는 열은 무시됩니다.
     
    - 네츄럴 조인은 예측하기 어렵고 버그를 유발할 가능성이 있기 때문에 일반적으로 권장되지 않습니다.
   
 예시
 ```
 SELECT *
 FROM employees
 NATURAL JOIN departments;
```
 크로스 조인과 네츄럴 조인은 일반적으로 사용하지 않거나 권장되지 않는 조인 유형입니다. 
 
 이유는  크로스 조인은 결과가 매우 크고 성능에 부정적인 영향을 미칠 수 있으므로 조심해서 사용해야 합니다.
 
 네츄럴 조인은 열 이름이 일치하는 경우에만 작동하며, 스키마 변경 시 예기치 않은 결과를 초래할 수 있습니다. 
 
 따라서 명시적인 JOIN 조건을 사용하는 것이 더 안전합니다.  
   
------------------------------------------------------------------------------------------------------------

## INNER JOIN

INNER JOIN은 ON 절과 함께 사용되며, ON 절의 조건을 만족하는 데이터만을 가져옵니다.

```
1. 첫번째테이블이름

INNER JOIN 두번째테이블이름

ON 조건

2. 첫번째테이블이름

JOIN 두번째테이블이름

ON 조건
```
 

ON 절에서는 WHERE 절에서 사용할 수 있는 모든 조건을 사용할 수 있습니다.

표준 SQL과는 달리 MySQL에서는 JOIN, INNER JOIN, CROSS JOIN이 모두 같은 의미로 사용됩니다.

 

다음 예제는 Reservation 테이블의 Name 필드와 Customer 테이블의 Name 필드가 서로 일치하는 레코드만을 INNER JOIN으로 가져오는 예제입니다.


```
1. SELECT *

FROM Reservation

INNER JOIN Customer

ON Reservation.Name = Customer.Name;

2. SELECT *

FROM Reservation

JOIN Customer

ON Reservation.Name = Customer.Name;
```



- INNER JOIN의 결과를 벤 다이어그램으로 나타내면 다음과 같습니다.

 
![img_mysql_inner_join](https://github.com/parkminseok56/Oracle/assets/133790403/28749f74-cdaa-4519-80ca-f72550fd8a89)


 

 

INNER JOIN의 경우에는 앞서 살펴본 표준 SQL 방식과는 별도로 MySQL에서만 사용할 수 있는 방식이 따로 존재합니다.

다음 예제는 앞서 살펴본 INNER JOIN 예제와 같은 실행 결과를 보여줍니다.


```
SELECT *

FROM Reservation, Customer

WHERE Reservation.Name = Customer.Name;
```
 

위의 예제처럼 테이블의 이름이 길거나 복잡한 경우에는 별칭(alias)을 사용하여 SQL 구문을 간략화할 수 있습니다.

 

다음 예제는 앞의 예제를 별칭(alias)을 사용하여 간략화한 예제입니다.

```
SELECT *

FROM Reservation AS r, Customer AS c

WHERE r.Name = c.Name;
```

## LEFT JOIN

LEFT JOIN은 첫 번째 테이블을 기준으로, 두 번째 테이블을 조합하는 JOIN입니다. 

 

이때 ON 절의 조건을 만족하지 않는 경우에는 첫 번째 테이블의 필드 값은 그대로 가져옵니다.

하지만 해당 레코드의 두 번째 테이블의 필드 값은 모두 NULL로 표시됩니다.



```
첫번째테이블이름

LEFT JOIN 두번째테이블이름

ON 조건
```
 

ON 절에서는 WHERE 절에서 사용할 수 있는 모든 조건을 사용할 수 있습니다.

 

다음 예제는 Reservation 테이블의 Name 필드를 기준으로 Customer 테이블의 Name 필드와 일치하는 레코드만을 LEFT JOIN으로 가져온 후, 그 중에서 ReserveDate 필드의 값이 2016년 02월 01일 이후인 레코드만을 선택하는 예제입니다.

```
SELECT *

FROM Reservation

LEFT JOIN Customer

ON Reservation.Name = Customer.Name

WHERE ReserveDate > '2016-02-01';
```


위의 예제에서 두 개의 Name 값이 일치하면, INNER JOIN과 같이 두 테이블의 모든 필드를 그대로 가져옵니다.

하지만 두 개의 Name 값이 일치하지 않는 경우에는 Customer 테이블의 모든 필드를 NULL로 표시됩니다.

 

LEFT JOIN의 결과를 벤 다이어그램으로 나타내면 다음과 같습니다.

 
![img_mysql_left_join](https://github.com/parkminseok56/Oracle/assets/133790403/29511a06-2d4b-471d-9858-32cc1c45e732)



 

## RIGHT JOIN

RIGHT JOIN은 LEFT 조인과는 반대로 두 번째 테이블을 기준으로, 첫 번째 테이블을 조합하는 JOIN입니다. 

 

이때 ON 절의 조건을 만족하지 않는 경우에는 두 번째 테이블의 필드 값은 그대로 가져옵니다.

하지만 해당 레코드의 첫 번째 테이블의 필드 값은 모두 NULL로 표시됩니다.

문법

```

첫번째테이블이름

LEFT JOIN 두번째테이블이름

ON 조건

```
 

ON 절에서는 WHERE 절에서 사용할 수 있는 모든 조건을 사용할 수 있습니다.

 

다음 예제는 Customer 테이블의 Name 필드를 기준으로 Reservation 테이블의 Name 필드와 일치하는 레코드만을 RIGHT JOIN으로 가져오는 예제입니다.


```
SELECT *

FROM Reservation

RIGHT JOIN Customer

ON Reservation.Name = Customer.Name;
```

 

위의 예제에서 두 개의 Name 값이 일치하면, INNER JOIN과 같이 두 테이블의 모든 필드를 그대로 가져옵니다.

하지만 두 개의 Name 값이 일치하지 않는 경우에는 Reservation 테이블의 모든 필드를 NULL로 표시됩니다.

 

RIGHT JOIN의 결과를 벤 다이어그램으로 나타내면 다음과 같습니다.

![img_mysql_right_join](https://github.com/parkminseok56/Oracle/assets/133790403/ac8e81bb-f4e2-4672-bc3b-ff791b09cca8)

 ------------------------------------------------------------------------------------------------------------
 
 ### 인덱스(index)
 
- 인덱스(index)는 테이블에서 원하는 데이터를 쉽고 빠르게 찾기 위해 사용합니다.

 - 이러한 인덱스는 자주 사용되는 필드 값으로 만들어진 원본 테이블의 사본이라고 생각할 수 있습니다.

 

- MySQL은 데이터를 검색할 때 첫 번째 필드부터 차례대로 테이블 전체를 검색합니다.

- 따라서 테이블이 크면 클수록 데이터를 탐색하는 시간도 많이 늘어나게 됩니다.

 

- 하지만 인덱스를 사용하면 테이블 전체를 읽지 않아도 되므로, 검색과 질의에 대한 처리가 빠르게 이루어집니다.

- 이러한 인덱스는 사용자가 직접 접근할 수는 없으며, 검색과 질의에 대한 처리에서만 사용됩니다.

 

- 이렇게 인덱스가 설정된 필드 값을 포함한 데이터의 삽입, 삭제, 수정 작업이 원본 테이블에서 이루어질 경우, 인덱스도 함께 수정되어야 합니다.

- 따라서 인덱스가 설정된 테이블의 처리 속도가 느려질 수 있습니다.

- 그러므로 인덱스는 수정보다는 검색이 자주 사용되는 테이블에서 사용하는 것이 더 좋습니다.


 ------------------------------------------------------------------------------------------------------------

## 인덱스 생성

CREATE 문을 사용하여 인덱스를 생성할 수 있습니다.

 

MySQL에서 인덱스를 생성하는 문법은 다음과 같습니다.


문법

```
CREATE INDEX 인덱스이름

ON 테이블이름 (필드이름1, 필드이름2, ...)
```
 

이때 쉼표(,)를 사용하여 여러 필드를 가지는 인덱스를 생성할 수도 있습니다.

 

다음 예제는 Reservation 테이블의 Name 필드에 NameIdx라는 인덱스를 설정하는 예제입니다.

예제
 
```
CREATE INDEX NameIdx

On Reservation (Name);
```
 

 ------------------------------------------------------------------------------------------------------------


## 인덱스 정보 보기

위와 같이 생성한 인덱스는 다음과 같은 문법을 통해 확인할 수 있습니다.

문법
```
SHOW INDEX

FROM 테이블이름
```
 

위와 같은 문법을 사용하면 해당 테이블에 생성된 모든 인덱스의 정보를 보여줍니다.

이때 반환되는 인덱스 정보의 필드 값은 다음과 같습니다.

 

1. Table : 테이블의 이름을 표시함.

2. Non_unique : 인덱스가 중복된 값을 저장할 수 있으면 1, 저장할 수 없으면 0을 표시함.

3. Key_name : 인덱스의 이름을 표시하며, 인덱스가 해당 테이블의 기본 키라면 PRIMARY로 표시함.

4. Seq_in_index : 인덱스에서의 해당 필드의 순서를 표시함.

5. Column_name : 해당 필드의 이름을 표시함.

6. Collation : 인덱스에서 해당 필드가 정렬되는 방법을 표시함.

7. Cardinality : 인덱스에 저장된 유일한 값들의 수를 표시함.

8. Sub_part : 인덱스 접두어를 표시함.

9. Packed : 키가 압축되는(packed) 방법을 표시함.

10. Null : 해당 필드가 NULL을 저장할 수 있으면 YES를 표시하고, 저장할 수 없으면 ''를 표시함.

11. Index_type : 인덱스에 사용되는 메소드(method)를 표시함.

12. Comment : 해당 필드를 설명하는 것이 아닌 인덱스에 관한 기타 정보를 표시함.

13. Index_comment : 인덱스에 관한 모든 기타 정보를 표시함.

UNIQUE INDEX 생성
UNIQUE INDEX는 중복 값을 허용하지 않는 인덱스입니다.

------------------------------------------------------------------------------------------------------------ 

### MySQL에서 UNIQUE INDEX를 생성하는 문법

문법
111
CREATE UNIQUE INDEX 인덱스이름

ON 테이블이름 (필드이름1, 필드이름2, ...)
111
 

또한, 쉼표(,)를 사용하여 여러 필드에 UNIQUE INDEX를 설정해 줄 수도 있습니다.

 

다음 예제는 Reservation 테이블의 ID 필드에 IdIdx라는 UNIQUE INDEX를 설정하는 예제입니다.

예제
 
111
CREATE UNIQUE INDEX IdIdx

On Reservation (ID);
111
 


------------------------------------------------------------------------------------------------------------ 


## 인덱스 정렬

인덱스를 생성할 때 인덱스에 포함되는 필드의 정렬 방식을 설정할 수 있습니다.

DESC 키워드를 사용하면 내림차순으로 정렬되며, ASC 키워드를 사용하면 오름차순으로 정렬됩니다.

문법
```
1. CREATE INDEX 인덱스이름

   ON 테이블이름 (필드이름 DESC)

2. CREATE INDEX 인덱스이름

   ON 테이블이름 (필드이름 ASC)
```

 

다음 예제는 Reservation 테이블의 Name 필드에 NameDescIdx라는 인덱스를 설정하는 예제입니다.

이때 Name 필드의 값들은 내림차순으로 정렬됩니다.


예제
 
```
CREATE INDEX NameDescIdx

On Reservation (Name DESC);
```
 








# JDBC

- JDBC(Java Database Connectivity)는 자바 프로그래밍 언어를 통해 관계형 데이터베이스 시스템에 접속하고 상호 작용하기 위한 자바 API(응용 프로그래밍 인터페이스)입니다.

- JDBC는 데이터베이스와의 통신을 추상화하고 표준화하기 위해 개발된 API로서, 다양한 데이터베이스 관리 시스템(DBMS)과 상호 작용할 수 있는 일관된 방법을 제공합니다.
  
------------------------------------------------------------------------------------------------------------
## JDBC의 기능

-  데이터베이스 연결 및 접속: JDBC를 사용하여 데이터베이스 서버에 연결하고 세션을 생성할 수 있습니다.
 
- 쿼리 실행: SQL 쿼리를 생성하고 실행하여 데이터베이스에서 데이터를 조회하거나 업데이트할 수 있습니다.
 
- 트랜잭션 관리: JDBC를 사용하여 트랜잭션을 시작하고 커밋 또는 롤백할 수 있습니다.
 
- 결과 처리: 쿼리 실행 결과를 받아와서 자바 객체로 변환하거나 처리할 수 있습니다.
 
- 예외 처리: 데이터베이스 연결 및 쿼리 실행 시 발생하는 예외를 처리할 수 있습니다.
 
- Batch 처리: 여러 개의 쿼리를 한 번에 실행하는 Batch 작업을 수행할 수 있습니다.
 
- PreparedStatement 사용: SQL 인젝션을 방지하기 위해 동적 쿼리에 사용되는 PreparedStatement를 활용할 수 있습니다.

------------------------------------------------------------------------------------------------------------
# 주요 내장 객체

 ## connection 객체

  - 데이터베이스와의 연결을 관리하기 위한 중요한 객체임.
  - 이 객체는 JDBC(Java Database Connectivity)를 통해 데이터베이스와 통신하는 데 사용됨.
  - JDBC는 자바 프로그램에서 다양한 관계형 데이터베이스 시스템과 상호 작용할 수 있도록 해주는 API 집합을 제공함.
------------------------------------------------------------------------------------------------------------
주요 역할

  -   데이터베이스 연결: Connection 객체는 데이터베이스에 연결을 생성하고 관리합니다. 데이터베이스 서버와의 실제 연결을 나타내며, 데이터베이스에 쿼리를 실행하거나 업데이트를 수행하는 데 사용됩니다.
     
  -   트랜잭션 관리: Connection 객체는 트랜잭션을 시작하고 종료하며, 트랜잭션 내에서 실행되는 모든 쿼리와 업데이트 작업을 제어합니다. 트랜잭션은 데이터베이스 작업의 논리적 단위를 나타내며, 원자성, 일관성, 격리성, 지속성(ACID 원칙)을 보장하기 위해 사용됩니다.
     
 -    Statement 생성: Connection 객체를 사용하여 Statement 객체를 생성할 수 있습니다. Statement는 정적인 SQL 쿼리를 실행하는 데 사용되며, PreparedStatement나 CallableStatement와 같은 더 강력한 기능을 제공하는 서브 클래스도 있습니다.
     
 -    자원 관리: Connection 객체를 사용한 후에는 반드시 명시적으로 닫아야 합니다. 이는 데이터베이스 리소스를 효율적으로 관리하고 메모리 누수를 방지하기 위함입니다. Connection을 닫으면 해당 연결이 종료되고 관련된 모든 자원이 해제됩니다.
     
  -   Connection Pooling: Connection 객체의 생성과 해제는 비용이 큰 작업일 수 있습니다. 따라서 매번 필요할 때마다 Connection을 새로 생성하고 닫는 대신, Connection Pooling 기술을 사용하여 미리 생성된 Connection 객체들을 관리하고 재사용할 수 있습니다.

------------------------------------------------------------------------------------------------------------

## PreparedStatement 객체

   -   JDBC(Java Database Connectivity)에서 제공하는 객체 중 하나로, 동적인 SQL 쿼리를 실행하기 위해 사용되는 기능을 제공하는 클래스입니다.
   -   PreparedStatement를 사용하면 쿼리를 미리 준비하고 나중에 파라미터 값을 *바인딩하여 실행할 수 있습니다.
   -   이를 통해 SQL 인젝션과 같은 보안 문제를 방지하면서 성능을 향상시킬 수 있습니다.

------------------------------------------------------------------------------------------------------------
 -  주요 특징 

    -  SQL Injection 방지: PreparedStatement를 사용하면 쿼리의 파라미터 값을 문자열 치환 없이 바인딩하여 쿼리를 실행할 수 있습니다. 이렇게 하면 악의적인 사용자가 입력한 값을 그대로 사용하는 것을 방지하고, 보안 문제인 SQL 인젝션을 예방할 수 있습니다.
      
    -   캐시 활용 및 성능 향상: 데이터베이스 시스템은 PreparedStatement 객체를 캐시에 저장하여 이후에 동일한 쿼리를 실행할 때 성능을 향상시킬 수 있습니다. 매번 동일한 쿼리를 생성하지 않고 미리 준비된 쿼리를 사용하기 때문입니다.
      
    -  가독성 향상: PreparedStatement는 동적인 쿼리를 작성하기 위해 문자열 치환보다는 파라미터 바인딩을 사용하기 때문에 가독성이 높아집니다.
       
